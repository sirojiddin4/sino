<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sino - AI IELTS Tutor - Test Page</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="/static/css/main.css">
    <style>
        /* Inline styles for critical components */
        .practice-buttons-debug {
            height: 100px !important;
            background-color: #f8f9fa !important;
        }
        
        .practice-button-debug {
            height: 38px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        
        .chat-history-container {
            max-height: 100px !important;
            overflow-y: auto !important;
        }
        
        #chatInterface {
            height: 550px !important;
            display: flex !important;
            flex-direction: column !important;
        }

        /* Navigation panel styles */
        .bottom-nav-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #f8f9fa;
            padding: 8px 10px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        /* Add bottom padding to main content to prevent overlap with fixed bottom nav */
        .main-content {
            padding-bottom: 70px; /* Reduced from 100px */
        }
        
        /* Improved height management for content areas */
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        
        /* Prevent unnecessary scrolling by making the main container fill the viewport */
        .container-fluid.px-0 {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Make question nav buttons more compact */
        .question-nav-btn {
            margin: 0;
            width: 26px;
            height: 26px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            border-radius: 4px;
            margin-right: 1px;
            margin-bottom: 1px;
            transition: all 0.2s ease;
        }
        
        /* Style for answered questions - gold background, black text, no border */
        .question-nav-btn.answered {
            background-color: #FFD700; /* Gold color */
            color: #000;
            border-color: #FFD700;
            font-weight: 500;
        }
        
        /* Style for questions marked for review - circle shape */
        .question-nav-btn.review {
            border-radius: 50%;
        }
        
        /* Active question button (currently viewed) */
        .question-nav-btn.active {
            background-color: #FFD700 !important; /* Gold for answered questions */
            color: #000 !important;
            border-color: #FFD700 !important;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.5); /* Blue outline to indicate current question */
        }
        
        /* For unanswered active questions */
        .question-nav-btn.active:not(.answered) {
            background-color: #007bff !important; /* Primary blue */
            color: #fff !important;
            border-color: #007bff !important;
        }

        /* Questions navigation container */
        .questions-nav-container {
            flex: 1;
            display: flex;
            justify-content: center;
            overflow-x: auto;
            margin: 0 10px;
            padding: 0 5px;
            max-width: 75%;
        }

        /* Mobile responsiveness for navigation buttons */
        @media (max-width: 768px) {
            .question-nav-btn {
                width: 24px;
                height: 24px;
                font-size: 0.65rem;
                margin: 0;
            }
            
            .bottom-nav-panel .btn-sm {
                font-size: 0.7rem;
                padding: 0.25rem 0.5rem;
            }
            
            .review-checkbox-container {
                margin-right: 3px;
            }
            
            .review-checkbox-container label {
                font-size: 0.7rem;
            }
        }
        
        /* Review checkbox in navigation */
        .review-checkbox-container {
            white-space: nowrap;
            padding-right: 5px;
            min-width: 70px;
        }

        .navigation-controls {
            white-space: nowrap;
            padding-left: 5px;
            display: flex;
            align-items: center;
        }

        /* Improve scrollbar appearance for question navigation */
        .questions-nav-container::-webkit-scrollbar {
            height: 4px;
        }
        
        .questions-nav-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .questions-nav-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .questions-nav-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* For the scrollbar in the reading passage container */
        .reading-passage-container::-webkit-scrollbar {
            width: 8px;
        }

        .reading-passage-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .reading-passage-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .reading-passage-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* New styles for collapsible questions */
        .questions-container {
            height: 77vh;
            overflow-y: auto;
            padding-right: 5px;
        }

        .question-accordion {
            margin-bottom: 12px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            overflow: hidden;
        }

        .question-header {
            background-color: #f8f9fa;
            padding: 10px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #dee2e6;
            transition: background-color 0.2s;
        }

        .question-header:hover {
            background-color: #e9ecef;
        }

        .question-header.answered {
            background-color: #fff3cd;
        }

        .question-header.active {
            background-color: #cfe2ff;
        }

        .question-body {
            padding: 15px;
            display: none;
        }

        .question-body.open {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .chevron-icon {
            transition: transform 0.3s ease;
        }

        .chevron-icon.open {
            transform: rotate(180deg);
        }

        .answered-badge {
            background-color: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            display: none;
        }

        .answered-badge.visible {
            display: inline-block;
        }

        .review-badge {
            background-color: #fd7e14;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 5px;
            display: none;
        }

        .review-badge.visible {
            display: inline-block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* For the scrollbar in the questions container */
        .questions-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .questions-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .questions-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .questions-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Highlight styles */
        .highlighted-text {
            background-color: #FFEB3B;
            border-radius: 2px;
        }
        
        .custom-context-menu {
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="container-fluid px-0" style="height:650px; overflow-y: hidden;">
        <!-- Main content starts here -->
        <div class="container-fluid mb-5 main-content" style="height:65px;">
            <!-- Header with User's Name, Timer, and Part Information -->
            <div class="row bg-light py-1 mb-3 position-sticky top-0 shadow-sm" style="z-index: 1000;">
                <div class="col-6">
                    <div>
                        <span class="fw-bold">{{ request.user.username }}</span>
                    </div>
                    <div>
                        <span>Part 1 Read the text and answer questions 1–{{ questions|length }}</span>
                    </div>
                </div>
                <div class="col-6 text-end">
                    <span id="timer" class="fw-bold" data-remaining="{{ remaining_seconds }}">
                        {% if remaining_seconds > 0 %}
                            {{ remaining_seconds }} seconds
                        {% else %}
                            Time's up!
                        {% endif %}
                    </span>
                </div>
            </div>
            
            <div class="row">
                <!-- Reading Passage -->
                <div class="col-md-6">
                    <div class="card mb-3">
                        <div class="card-body reading-passage-container" style="height: 80vh; overflow-y: auto;">
                            <h4 class="mb-3">{{ passage.title }}</h4>
                            <div class="reading-passage">
                                {{ passage.content|linebreaks }}
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Questions -->
                <div class="col-md-6" style="height: 80vh; overflow-y: auto;">
                    <div class="card">
                        <div class="card-body p-2" >
                            <div class="questions-container">
                                {% for question in questions %}
                                <div class="question-accordion" data-question-id="{{ question.id }}">
                                    <div class="question-header" id="question-header-{{ question.id }}">
                                        <div>
                                            <span class="fw-bold">Question {{ forloop.counter }}</span>
                                            <span class="answered-badge {% if question.user_answer.answer and question.user_answer.answer != '' %}visible{% endif %}">Answered</span>
                                            <span class="review-badge {% if question.user_answer.marked_for_review %}visible{% endif %}">Review</span>
                                        </div>
                                        <i class="bi bi-chevron-down chevron-icon"></i>
                                    </div>
                                    <div class="question-body" id="question-body-{{ question.id }}">
                                        <div class="question-container" data-question-id="{{ question.id }}" id="question-{{ question.id }}">
                                            <p>{{ question.text }}</p>
                                            
                                            {% if question.question_type == 'multiple_choice' %}
                                                {% for option in question.options.all %}
                                                <div class="form-check">
                                                    <input class="form-check-input answer-input" type="radio" name="question_{{ question.id }}" id="option_{{ option.id }}" value="{{ option.id }}" 
                                                    {% if question.user_answer.answer == option.id|stringformat:"s" %}checked{% endif %}>
                                                    <label class="form-check-label" for="option_{{ option.id }}">
                                                        {{ option.text }}
                                                    </label>
                                                </div>
                                                {% endfor %}
                                            {% elif question.question_type == 'true_false' %}
                                                <div class="form-check">
                                                    <input class="form-check-input answer-input" type="radio" name="question_{{ question.id }}" id="true_{{ question.id }}" value="true" 
                                                    {% if question.user_answer.answer == "true" %}checked{% endif %}>
                                                    <label class="form-check-label" for="true_{{ question.id }}">
                                                        True
                                                    </label>
                                                </div>
                                                <div class="form-check">
                                                    <input class="form-check-input answer-input" type="radio" name="question_{{ question.id }}" id="false_{{ question.id }}" value="false" 
                                                    {% if question.user_answer.answer == "false" %}checked{% endif %}>
                                                    <label class="form-check-label" for="false_{{ question.id }}">
                                                        False
                                                    </label>
                                                </div>
                                            {% else %}
                                                <div class="form-group">
                                                    <textarea class="form-control answer-input" id="answer_{{ question.id }}" rows="3" placeholder="Enter your answer here...">{{ question.user_answer.answer }}</textarea>
                                                </div>
                                            {% endif %}
                                        </div>
                                    </div>
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Navigation Panel -->
        <div class="bottom-nav-panel">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-12">
                        <div class="d-flex justify-content-between align-items-center">
                            <!-- Review Checkbox in Navigation -->
                            <div class="review-checkbox-container d-flex align-items-center">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="nav_review_checkbox">
                                    <label class="form-check-label" for="nav_review_checkbox">
                                        Review
                                    </label>
                                </div>
                            </div>
                            
                            <!-- Question Navigation Buttons -->
                            <div class="questions-nav-container">
                                <div class="d-flex flex-wrap">
                                    {% for question in questions %}
                                        <button class="btn btn-outline-primary question-nav-btn" data-question-id="{{ question.id }}">{{ forloop.counter }}</button>
                                    {% endfor %}
                                </div>
                            </div>
                            
                            <!-- Navigation Controls -->
                            <div class="navigation-controls">
                                <button class="btn btn-secondary btn-sm me-1" id="prevBtn">← Prev</button>
                                <button class="btn btn-secondary btn-sm me-1" id="nextBtn">Next →</button>
                                <button class="btn btn-primary btn-sm" id="submitBtn">Submit</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Submit Confirmation Modal -->
        <div class="modal fade" id="submitModal" tabindex="-1" aria-labelledby="submitModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="submitModalLabel">Confirm Submission</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        Are you sure you want to submit your test? You won't be able to make changes after submission.
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <a href="{% url 'submit_test' session.id %}" class="btn btn-primary">Submit Test</a>
                    </div>
                </div>
            </div>
        </div>
        
    <!-- Bootstrap JS Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Custom JS -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const timerEl = document.getElementById('timer');
            const questionAccordions = document.querySelectorAll('.question-accordion');
            const navigationBtns = document.querySelectorAll('.question-nav-btn');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const submitBtn = document.getElementById('submitBtn');
            const currentQuestionLabel = document.getElementById('currentQuestionLabel');
            const answerInputs = document.querySelectorAll('.answer-input');
            const navReviewCheckbox = document.getElementById('nav_review_checkbox');
            
            // Set up CSRF token for AJAX requests
            const csrfToken = "{{ csrf_token }}";
            
            let currentQuestionIndex = 0;
            let remainingSeconds = parseInt(timerEl.dataset.remaining);
            
            // Update timer every second
            const timerInterval = setInterval(function() {
                remainingSeconds--;
                
                if (remainingSeconds <= 0) {
                    clearInterval(timerInterval);
                    timerEl.textContent = "Time's up!";
                    
                    // Auto-submit the test
                    window.location.href = "{% url 'submit_test' session.id %}";
                } else {
                    const minutes = Math.floor(remainingSeconds / 60);
                    const seconds = remainingSeconds % 60;
                    timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);

            // Toggle question accordion
            questionAccordions.forEach((accordion, index) => {
                const header = accordion.querySelector('.question-header');
                const body = accordion.querySelector('.question-body');
                const chevron = header.querySelector('.chevron-icon');
                
                header.addEventListener('click', () => {
                    // Toggle the current accordion
                    const isOpen = body.classList.contains('open');
                    
                    if (isOpen) {
                        // Close this accordion
                        body.classList.remove('open');
                        chevron.classList.remove('open');
                    } else {
                        // Open this accordion
                        body.classList.add('open');
                        chevron.classList.add('open');
                    }
                    
                    // Update current question index for navigation
                    currentQuestionIndex = index;
                    
                    // Update the review checkbox in navigation based on current question's review status
                    updateNavigationCheckbox(index);
                    
                    // Highlight the corresponding navigation button
                    updateNavigationHighlight(index);
                });
            });
            
            // Show a specific question and scroll to it
            function showQuestion(index) {
                if (index < 0 || index >= questionAccordions.length) return;
                
                const targetAccordion = questionAccordions[index];
                const targetHeader = targetAccordion.querySelector('.question-header');
                const targetBody = targetAccordion.querySelector('.question-body');
                const targetChevron = targetHeader.querySelector('.chevron-icon');
                
                // Open the target accordion if it's not already open
                if (!targetBody.classList.contains('open')) {
                    targetBody.classList.add('open');
                    targetChevron.classList.add('open');
                }
                
                // Scroll to the target accordion
                targetAccordion.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // Update current question index
                currentQuestionIndex = index;
                
                // Update navigation button states
                prevBtn.disabled = index === 0;
                nextBtn.disabled = index === questionAccordions.length - 1;
                
                // Update the review checkbox in navigation based on current question's review status
                updateNavigationCheckbox(index);
                
                // Highlight the corresponding navigation button
                updateNavigationHighlight(index);
            }
            
            // Update navigation highlight
            function updateNavigationHighlight(index) {
                navigationBtns.forEach((btn, btnIndex) => {
                    btn.classList.remove('active');
                    if (btnIndex === index) {
                        btn.classList.add('active');
                    }
                });
            }
            
            // Update navigation checkbox based on question review status
            function updateNavigationCheckbox(index) {
                const questionId = questionAccordions[index].dataset.questionId;
                const accordion = questionAccordions[index];
                const reviewBadge = accordion.querySelector('.review-badge');
                navReviewCheckbox.checked = reviewBadge.classList.contains('visible');
            }
            
            // Navigation button event listeners
            navigationBtns.forEach((btn, index) => {
                btn.addEventListener('click', () => {
                    showQuestion(index);
                });
            });
            
            // Previous button event listener
            prevBtn.addEventListener('click', () => {
                if (currentQuestionIndex > 0) {
                    showQuestion(currentQuestionIndex - 1);
                }
            });
            
            // Next button event listener
            nextBtn.addEventListener('click', () => {
                if (currentQuestionIndex < questionAccordions.length - 1) {
                    showQuestion(currentQuestionIndex + 1);
                }
            });
            
            // Submit button event listener
            submitBtn.addEventListener('click', () => {
                const submitModal = new bootstrap.Modal(document.getElementById('submitModal'));
                submitModal.show();
            });
            
            // Save answer when input changes
            answerInputs.forEach(input => {
                if (input.type === 'radio') {
                    // For radio buttons, add click handler to allow deselection
                    input.addEventListener('click', (e) => {
                        // Find all radio buttons in the same group
                        const name = input.getAttribute('name');
                        const radioGroup = document.querySelectorAll(`input[name="${name}"]`);
                        
                        // If this radio is already checked, uncheck it and prevent default
                        if (input.getAttribute('data-previously-checked') === 'true') {
                            e.preventDefault();
                            
                            // Uncheck this radio button
                            input.checked = false;
                            
                            // Reset the previously-checked attribute for all radios in the group
                            radioGroup.forEach(radio => {
                                radio.setAttribute('data-previously-checked', 'false');
                            });
                            
                            // Call saveAnswer with the container to handle the deselection
                            const container = input.closest('.question-container');
                            saveAnswerForContainer(container, '');
                        } else {
                            // Update previously-checked attribute for all radios in the group
                            radioGroup.forEach(radio => {
                                radio.setAttribute('data-previously-checked', 'false');
                            });
                            
                            // Mark only this one as checked
                            input.setAttribute('data-previously-checked', 'true');
                            
                            // Save the answer
                            saveAnswer(input);
                        }
                    });
                } else {
                    // For other inputs like textareas
                    input.addEventListener('change', () => {
                        saveAnswer(input);
                    });
                    
                    if (input.tagName === 'TEXTAREA') {
                        // Add input event to catch deletions in real-time
                        input.addEventListener('input', () => {
                            saveAnswer(input);
                        });
                        
                        input.addEventListener('blur', () => {
                            saveAnswer(input);
                        });
                    }
                }
            });
            
            // Navigation review checkbox event listener
            navReviewCheckbox.addEventListener('change', () => {
                const currentAccordion = questionAccordions[currentQuestionIndex];
                const questionId = currentAccordion.dataset.questionId;
                const markForReview = navReviewCheckbox.checked;
                
                // Update the review badge
                const reviewBadge = currentAccordion.querySelector('.review-badge');
                if (markForReview) {
                    reviewBadge.classList.add('visible');
                } else {
                    reviewBadge.classList.remove('visible');
                }
                
                // Get the answer value from the current question
                let answerValue = '';
                const container = currentAccordion.querySelector('.question-container');
                
                const radioInputs = container.querySelectorAll('input[type="radio"]:checked');
                if (radioInputs.length > 0) {
                    answerValue = radioInputs[0].value;
                } else {
                    const textarea = container.querySelector('textarea');
                    if (textarea) {
                        answerValue = textarea.value;
                    }
                }
                
                // Send the data to the server
                sendAnswerToServer(questionId, answerValue, markForReview);
                
                // Update the navigation button appearance for review status
                navigationBtns[currentQuestionIndex].classList.toggle('review', markForReview);
            });
            
            // Function to save an answer
            function saveAnswer(inputElement) {
                const container = inputElement.closest('.question-container');
                let answerValue;
                
                if (inputElement.type === 'radio') {
                    // For radio buttons, only get value if checked
                    answerValue = inputElement.checked ? inputElement.value : '';
                } else if (inputElement.tagName === 'TEXTAREA') {
                    answerValue = inputElement.value;
                }
                
                saveAnswerForContainer(container, answerValue);
            }
            
            // Function to save answer from a container
            function saveAnswerForContainer(container, answerValue) {
                const questionId = container.dataset.questionId;
                
                // Find the accordion this answer belongs to
                const accordion = container.closest('.question-accordion');
                const header = accordion.querySelector('.question-header');
                const answeredBadge = accordion.querySelector('.answered-badge');
                
                // Find which index this question is
                const questionIndex = Array.from(questionAccordions).findIndex(
                    accord => accord.dataset.questionId === questionId
                );
                
                if (questionIndex > -1) {
                    // Check if the answer is empty
                    if (answerValue && answerValue.trim() !== '') {
                        // Mark the corresponding nav button as answered
                        navigationBtns[questionIndex].classList.add('answered');
                        
                        // Update the question header to show it's answered
                        header.classList.add('answered');
                        
                        // Show the answered badge
                        answeredBadge.classList.add('visible');
                        
                        // Remove bootstrap classes that would override our custom styling
                        navigationBtns[questionIndex].classList.remove('btn-outline-primary');
                    } else {
                        // Remove answered class if answer is empty
                        navigationBtns[questionIndex].classList.remove('answered');
                        
                        // Update the question header to show it's not answered
                        header.classList.remove('answered');
                        
                        // Hide the answered badge
                        answeredBadge.classList.remove('visible');
                        
                        // Restore original styling by adding btn-outline-primary
                        // (but not if it's the currently active question)
                        if (questionIndex !== currentQuestionIndex) {
                            navigationBtns[questionIndex].classList.add('btn-outline-primary');
                        } else {
                            // For active question that's now unanswered
                            navigationBtns[questionIndex].classList.add('btn-primary');
                            navigationBtns[questionIndex].classList.remove('btn-outline-primary');
                        }
                    }
                }
                
                // Get the review status from the navigation review checkbox if this is the current question
                let markForReview = false;
                if (questionIndex === currentQuestionIndex) {
                    markForReview = navReviewCheckbox.checked;
                } else {
                    // For other questions, maintain their current review status
                    const reviewBadge = accordion.querySelector('.review-badge');
                    markForReview = reviewBadge.classList.contains('visible');
                }
                
                // Send the data to the server
                sendAnswerToServer(questionId, answerValue || '', markForReview);
            }
            
            // Function to send answer to server
            function sendAnswerToServer(questionId, answer, markForReview) {
                const url = `{% url 'save_answer' session_id=session.id question_id=0 %}`.replace('0', questionId);
                
                const formData = new FormData();
                formData.append('answer', answer);
                formData.append('mark_for_review', markForReview);
                
                fetch(url, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': csrfToken,
                    },
                    body: formData,
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status !== 'success') {
                        console.error('Error saving answer:', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
            }
            
            // Initialize review markers and answered questions
            {% for question in questions %}
                // Find the navigation button for this question
                const navButton{{ forloop.counter }} = document.querySelector(`.question-nav-btn[data-question-id="{{ question.id }}"]`);
                const questionHeader{{ forloop.counter }} = document.querySelector(`#question-header-{{ question.id }}`);
                
                if (navButton{{ forloop.counter }} && questionHeader{{ forloop.counter }}) {
                    {% if question.user_answer.marked_for_review %}
                        navButton{{ forloop.counter }}.classList.add('review');
                    {% endif %}
                    
                    // Mark as answered if there's an answer
                    {% if question.user_answer.answer and question.user_answer.answer != "" %}
                        navButton{{ forloop.counter }}.classList.add('answered');
                        navButton{{ forloop.counter }}.classList.remove('btn-outline-primary');
                        questionHeader{{ forloop.counter }}.classList.add('answered');
                    {% endif %}
                }
            {% endfor %}
            
            // Mark previously checked radio buttons
            document.querySelectorAll('input[type="radio"]:checked').forEach(radio => {
                radio.setAttribute('data-previously-checked', 'true');
            });
            
            // Initialize: Open the first question by default
            const firstBody = questionAccordions[0].querySelector('.question-body');
            const firstChevron = questionAccordions[0].querySelector('.chevron-icon');
            if (firstBody && firstChevron) {
                firstBody.classList.add('open');
                firstChevron.classList.add('open');
            }
            
            // Update the navigation highlight for the first question
            updateNavigationHighlight(0);
            
            // Update the navigation checkbox for the first question
            updateNavigationCheckbox(0);
        });
    </script>
    
    <!-- Text Highlighting Implementation -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Target elements where we want to enable highlighting
            const readingPassage = document.querySelector('.reading-passage');
            const questionContainers = document.querySelectorAll('.question-container');
            
            // Track highlighted text spans
            let highlightedSpans = [];
            
            // Create and append the custom context menu
            const contextMenu = document.createElement('div');
            contextMenu.className = 'custom-context-menu';
            contextMenu.style.cssText = `
                position: absolute;
                background-color: white;
                border: 1px solid #ccc;
                border-radius: 4px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                padding: 5px 0;
                z-index: 1500;
                display: none;
            `;
            document.body.appendChild(contextMenu);
            
            // Add menu items to the context menu
            const highlightMenuItem = createMenuItem('Highlight', '#FFEB3B'); // Yellow highlight
            const removeHighlightMenuItem = createMenuItem('Remove Highlight');
            
            contextMenu.appendChild(highlightMenuItem);
            contextMenu.appendChild(removeHighlightMenuItem);
            
            // Function to create menu items
            function createMenuItem(text, color) {
                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                menuItem.textContent = text;
                menuItem.style.cssText = `
                    padding: 8px 12px;
                    cursor: pointer;
                    ${color ? `color: black;` : ''}
                `;
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.backgroundColor = '#f0f0f0';
                });
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.backgroundColor = 'transparent';
                });
                return menuItem;
            }
            
            // Apply context menu to reading passage
            if (readingPassage) {
                enableContextMenu(readingPassage);
            }
            
            // Apply context menu to all question containers
            questionContainers.forEach(container => {
                enableContextMenu(container);
            });
            
            // Function to enable context menu on an element
            function enableContextMenu(element) {
                element.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();
                    
                    // Check if selection contains any highlighted text
                    let selectionContainsHighlight = false;
                    let highlightSpansInSelection = [];
                    
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const container = document.createElement('div');
                        container.appendChild(range.cloneContents());
                        
                        // Check if this selection contains any highlighted spans
                        selectionContainsHighlight = container.querySelector('.highlighted-text') !== null;
                        
                        // Find all highlighted spans that intersect with the selection
                        document.querySelectorAll('.highlighted-text').forEach(span => {
                            if (selection.containsNode(span, true)) {
                                highlightSpansInSelection.push(span);
                            }
                        });
                    }
                    
                    // Only show menu if text is selected or click was on a highlight
                    if (selectedText || e.target.classList.contains('highlighted-text')) {
                        // Position the context menu
                        contextMenu.style.display = 'block';
                        contextMenu.style.left = `${e.pageX}px`;
                        contextMenu.style.top = `${e.pageY}px`;
                        
                        // Show both options if selection contains highlighted text and non-highlighted text
                        if (selectionContainsHighlight || e.target.classList.contains('highlighted-text')) {
                            highlightMenuItem.style.display = selectedText ? 'block' : 'none';
                            removeHighlightMenuItem.style.display = 'block';
                            
                            // Add click event to remove highlight
                            removeHighlightMenuItem.onclick = function() {
                                if (highlightSpansInSelection.length > 0) {
                                    // Remove all highlighted spans in the selection
                                    highlightSpansInSelection.forEach(span => {
                                        removeHighlight(span);
                                    });
                                } else if (e.target.classList.contains('highlighted-text')) {
                                    // Remove the specific target span
                                    removeHighlight(e.target);
                                }
                                hideContextMenu();
                            };
                            
                            // Add click event to apply highlight (if text is selected)
                            if (selectedText) {
                                highlightMenuItem.onclick = function() {
                                    applyHighlight(selection);
                                    hideContextMenu();
                                };
                            }
                        } else if (selectedText) {
                            // Regular text selection with no highlights
                            highlightMenuItem.style.display = 'block';
                            removeHighlightMenuItem.style.display = 'none';
                            
                            // Add click event to apply highlight
                            highlightMenuItem.onclick = function() {
                                applyHighlight(selection);
                                hideContextMenu();
                            };
                        } else {
                            // No text selected and not on a highlight, hide menu
                            hideContextMenu();
                        }
                    } else {
                        // No text selected, hide menu
                        hideContextMenu();
                    }
                });
            }
            
            // Hide context menu when clicking elsewhere
            document.addEventListener('click', hideContextMenu);
            document.addEventListener('scroll', hideContextMenu);
            window.addEventListener('resize', hideContextMenu);
            
            // Function to hide the context menu
            function hideContextMenu() {
                contextMenu.style.display = 'none';
            }
            
            // Function to apply highlight to selected text
            function applyHighlight(selection) {
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                
                // First, check if we need to remove any existing highlights in this selection
                const container = document.createElement('div');
                container.appendChild(range.cloneContents());
                const hasHighlights = container.querySelector('.highlighted-text') !== null;
                
                if (hasHighlights) {
                    // If selection contains highlights, first remove them
                    removePartialHighlights(selection);
                    
                    // We need to reselect the text after removing highlights
                    // This is complex, so we'll show a notification to the user
                    createNotification("Highlights removed. Please select the text again to apply new highlight.");
                    return;
                }
                
                // Apply new highlight
                const span = document.createElement('span');
                span.className = 'highlighted-text';
                span.style.backgroundColor = '#FFEB3B'; // Yellow highlight
                span.style.borderRadius = '2px';
                
                try {
                    range.surroundContents(span);
                    highlightedSpans.push(span);
                    selection.removeAllRanges();
                } catch (e) {
                    console.error("Highlighting failed, possibly due to partial node selection:", e);
                    
                    // Try a more complex approach for partial selections
                    try {
                        // Create a new range to hold our highlight
                        const newRange = document.createRange();
                        
                        // Extract the contents of the original range
                        const fragment = range.extractContents();
                        
                        // Create a span to wrap the extracted content
                        const highlightSpan = document.createElement('span');
                        highlightSpan.className = 'highlighted-text';
                        highlightSpan.style.backgroundColor = '#FFEB3B';
                        highlightSpan.style.borderRadius = '2px';
                        
                        // Append the content to our span
                        highlightSpan.appendChild(fragment);
                        
                        // Insert the highlight span at the start of the original range
                        range.insertNode(highlightSpan);
                        
                        // Track the new highlight
                        highlightedSpans.push(highlightSpan);
                        
                        // Clear the selection
                        selection.removeAllRanges();
                    } catch (nestedError) {
                        console.error("Complex highlighting also failed:", nestedError);
                        // Notify user why highlighting failed
                        createNotification("Highlight failed. Please select complete words or sentences.");
                    }
                }
            }
            
            // Function to remove highlight
            function removeHighlight(highlightSpan) {
                if (!highlightSpan) return;
                
                // Get the parent node of the highlight span
                const parent = highlightSpan.parentNode;
                
                // Create a document fragment to hold the highlight's contents
                const fragment = document.createDocumentFragment();
                
                // Move all the highlight's children to the fragment
                while (highlightSpan.firstChild) {
                    fragment.appendChild(highlightSpan.firstChild);
                }
                
                // Replace the highlight span with its contents
                parent.replaceChild(fragment, highlightSpan);
                
                // Remove the span from our tracked array
                highlightedSpans = highlightedSpans.filter(span => span !== highlightSpan);
                
                // Normalize the parent to merge any adjacent text nodes
                parent.normalize();
            }
            
            // Function to handle selection that spans across multiple highlights
            function removePartialHighlights(selection) {
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                
                // Get all highlighted spans in the document
                const allHighlightedSpans = document.querySelectorAll('.highlighted-text');
                
                // Find spans that intersect with the current selection
                allHighlightedSpans.forEach(span => {
                    // Check if this span intersects with the selection
                    if (selection.containsNode(span, true)) {
                        removeHighlight(span);
                    }
                });
            }
            
            // Function to create temporary notification
            function createNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'highlight-notification';
                notification.textContent = message;
                notification.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 10px 15px;
                    border-radius: 4px;
                    z-index: 2000;
                    font-size: 14px;
                `;
                
                document.body.appendChild(notification);
                
                // Remove after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s';
                    setTimeout(() => document.body.removeChild(notification), 500);
                }, 3000);
            }
            
            // Add keyboard shortcut (Ctrl+H) for highlighting
            document.addEventListener('keydown', function(e) {
                // Check if Ctrl+H was pressed
                if (e.ctrlKey && e.key === 'h') {
                    e.preventDefault(); // Prevent browser's history shortcut
                    
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();
                    
                    if (selectedText) {
                        applyHighlight(selection);
                    }
                }
            });
        });
    </script>
    
    <!-- Debug script for static file loading -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Check if stylesheets loaded
        let stylesheetsLoaded = [];
        let customStylesLoaded = false;
        
        for (let i = 0; i < document.styleSheets.length; i++) {
            try {
                const href = document.styleSheets[i].href || 'inline';
                stylesheetsLoaded.push(href);
                if (href.includes('main.css')) {
                    customStylesLoaded = true;
                }
            } catch (e) {
                stylesheetsLoaded.push('Access error - could be CORS');
            }
        }
        
        console.log('Stylesheets loaded:', stylesheetsLoaded);
        console.log('Custom styles loaded:', customStylesLoaded);
        
        if (!customStylesLoaded) {
            console.warn('⚠️ WARNING: main.css not loaded! Check your static files configuration');
        }
    });
    </script>
</body>
</html>