{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sino - AI IELTS Tutor - Practice</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="{% static 'css/main.css' %}">
    <style>
        /* Navigation panel styles */
        .bottom-nav-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: #f8f9fa;
            padding: 8px 10px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
        }

        /* Add bottom padding to main content to prevent overlap with fixed bottom nav */
        .main-content {
            padding-bottom: 70px;
        }
        
        /* Improved height management for content areas */
        body, html {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        
        /* Prevent unnecessary scrolling by making the main container fill the viewport */
        .container-fluid.px-0 {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Make question nav buttons more compact */
        .question-nav-btn {
            margin: 0;
            width: 26px;
            height: 26px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            border-radius: 4px;
            margin-right: 1px;
            margin-bottom: 1px;
            transition: all 0.2s ease;
        }
        
        /* Style for answered questions - gold background, black text, no border */
        .question-nav-btn.answered {
            background-color: #FFD700; /* Gold color */
            color: #000;
            border-color: #FFD700;
            font-weight: 500;
        }
        
        /* Style for questions marked for review - circle shape */
        .question-nav-btn.review {
            border-radius: 50%;
        }
        
        /* Active question button (currently viewed) */
        .question-nav-btn.active {
            background-color: #FFD700 !important; /* Gold for answered questions */
            color: #000 !important;
            border-color: #FFD700 !important;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.5); /* Blue outline to indicate current question */
        }
        
        /* For unanswered active questions */
        .question-nav-btn.active:not(.answered) {
            background-color: #007bff !important; /* Primary blue */
            color: #fff !important;
            border-color: #007bff !important;
        }

        /* Questions navigation container */
        .questions-nav-container {
            flex: 1;
            display: flex;
            justify-content: center;
            overflow-x: auto;
            margin: 0 10px;
            padding: 0 5px;
            max-width: 75%;
        }

        /* Mobile responsiveness for navigation buttons */
        @media (max-width: 768px) {
            .question-nav-btn {
                width: 24px;
                height: 24px;
                font-size: 0.65rem;
                margin: 0;
            }
            
            .bottom-nav-panel .btn-sm {
                font-size: 0.7rem;
                padding: 0.25rem 0.5rem;
            }
            
            .review-checkbox-container {
                margin-right: 3px;
            }
            
            .review-checkbox-container label {
                font-size: 0.7rem;
            }
        }
        
        /* Review checkbox in navigation */
        .review-checkbox-container {
            white-space: nowrap;
            padding-right: 5px;
            min-width: 70px;
        }

        .navigation-controls {
            white-space: nowrap;
            padding-left: 5px;
            display: flex;
            align-items: center;
        }

        /* Improve scrollbar appearance for question navigation */
        .questions-nav-container::-webkit-scrollbar {
            height: 4px;
        }
        
        .questions-nav-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .questions-nav-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .questions-nav-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* For the scrollbar in the reading passage container */
        .reading-passage-container::-webkit-scrollbar {
            width: 8px;
        }

        .reading-passage-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .reading-passage-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }

        .reading-passage-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* New styles for questions */
        .questions-container {
            height: 77vh;
            overflow-y: auto;
            padding-right: 5px;
        }

        .question-item {
            margin-bottom: 20px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            background-color: #fff;
        }

        .question-item.answered {
            background-color: #fff3cd;
        }

        .question-item.active {
            background-color: #cfe2ff;
            border-color: #b6d4fe;
        }

        .question-title {
            font-weight: bold;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .answered-badge {
            background-color: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            display: none;
        }

        .answered-badge.visible {
            display: inline-block;
        }

        .review-badge {
            background-color: #fd7e14;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            margin-left: 5px;
            display: none;
        }

        .review-badge.visible {
            display: inline-block;
        }

        /* For the scrollbar in the questions container */
        .questions-container::-webkit-scrollbar {
            width: 8px;
        }
        
        .questions-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .questions-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        
        .questions-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Highlight styles */
        .highlighted-text {
            background-color: #FFEB3B;
            border-radius: 2px;
        }
        
        .custom-context-menu {
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="container-fluid px-0" style="height:100vh; overflow-y: hidden;">
        <!-- Main content starts here -->
        <div class="container-fluid mb-5 main-content">
            <!-- Header with User's Name, Timer, and Part Information -->
            <div class="row bg-light py-1 mb-3 position-sticky top-0 shadow-sm" style="z-index: 1000;">
                <div class="col-6">
                    <div>
                        <span class="fw-bold">{{ request.user.username }}</span>
                    </div>
                    <div>
                        <span>IELTS Reading Practice</span>
                    </div>
                </div>
                <div class="col-6 text-end">
                    <span id="timer" class="fw-bold" data-remaining="{{ remaining_seconds }}">
                        {% if remaining_seconds > 0 %}
                            {{ remaining_seconds }} seconds
                        {% else %}
                            Time's up!
                        {% endif %}
                    </span>
                </div>
            </div>
            
            <div class="row">
                <!-- Reading Passage -->
                <div class="col-md-6" style="height:72vh;">
                    <div class="card mb-3">
                        <div class="card-body">
                            <div class="reading-passage-container" style="height: 75vh; overflow-y: auto;">
                                <h4 class="mb-3">{{ passage.title }}</h4>
                                <div class="reading-passage">
                                    {{ passage.content|linebreaks }}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Questions -->
                <div class="col-md-6" style="height:72vh;">
                    <div class="card">
                        <div class="card-body p-2">
                            <div class="questions-container">
                                {% for question in questions %}
                                <div class="question-item {% if forloop.first %}active{% endif %}" data-question-id="{{ question.id }}" id="question-item-{{ question.id }}">
                                    <div class="question-title">
                                        <span>{{ question.order_number }}. {{ question.text }}</span>
                                        <div>
                                            <span class="answered-badge {% if question.user_answer.answer and question.user_answer.answer != '' %}visible{% endif %}">Answered</span>
                                            <span class="review-badge {% if question.user_answer.marked_for_review %}visible{% endif %}">Review</span>
                                        </div>
                                    </div>
                                    <div class="question-container" data-question-id="{{ question.id }}" id="question-{{ question.id }}">
                                        {% if question.question_type == 'multiple_choice' %}
                                            {% for option in question.options.all %}
                                            <div class="form-check">
                                                <input class="form-check-input answer-input" type="radio" name="question_{{ question.id }}" id="option_{{ option.id }}" value="{{ option.id }}" 
                                                {% if question.user_answer.answer == option.id|stringformat:"s" %}checked{% endif %}>
                                                <label class="form-check-label" for="option_{{ option.id }}">
                                                    {{ option.text }}
                                                </label>
                                            </div>
                                            {% endfor %}
                                        {% elif question.question_type == 'true_false' %}
                                            <div class="form-check">
                                                <input class="form-check-input answer-input" type="radio" name="question_{{ question.id }}" id="true_{{ question.id }}" value="true" 
                                                {% if question.user_answer.answer == "true" %}checked{% endif %}>
                                                <label class="form-check-label" for="true_{{ question.id }}">
                                                    True
                                                </label>
                                            </div>
                                            <div class="form-check">
                                                <input class="form-check-input answer-input" type="radio" name="question_{{ question.id }}" id="false_{{ question.id }}" value="false" 
                                                {% if question.user_answer.answer == "false" %}checked{% endif %}>
                                                <label class="form-check-label" for="false_{{ question.id }}">
                                                    False
                                                </label>
                                            </div>
                                        {% elif question.question_type == 'true_false_not_given' %}
                                            <div class="form-check">
                                                <input class="form-check-input answer-input" type="radio" name="question_{{ question.id }}" id="true_{{ question.id }}" value="TRUE" 
                                                {% if question.user_answer.answer == "TRUE" %}checked{% endif %}>
                                                <label class="form-check-label" for="true_{{ question.id }}">
                                                    TRUE
                                                </label>
                                            </div>
                                            <div class="form-check">
                                                <input class="form-check-input answer-input" type="radio" name="question_{{ question.id }}" id="false_{{ question.id }}" value="FALSE" 
                                                {% if question.user_answer.answer == "FALSE" %}checked{% endif %}>
                                                <label class="form-check-label" for="false_{{ question.id }}">
                                                    FALSE
                                                </label>
                                            </div>
                                            <div class="form-check">
                                                <input class="form-check-input answer-input" type="radio" name="question_{{ question.id }}" id="notgiven_{{ question.id }}" value="NOT GIVEN" 
                                                {% if question.user_answer.answer == "NOT GIVEN" %}checked{% endif %}>
                                                <label class="form-check-label" for="notgiven_{{ question.id }}">
                                                    NOT GIVEN
                                                </label>
                                            </div>
                                        {% else %}
                                            <div class="form-group">
                                                <textarea class="form-control answer-input" id="answer_{{ question.id }}" rows="3" placeholder="Enter your answer here...">{{ question.user_answer.answer }}</textarea>
                                            </div>
                                        {% endif %}
                                    </div>
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Navigation Panel -->
        <div class="bottom-nav-panel">
            <div class="container-fluid">
                <div class="row">
                    <div class="col-12">
                        <div class="d-flex justify-content-between align-items-center">
                            <!-- Review Checkbox in Navigation -->
                            <div class="review-checkbox-container d-flex align-items-center">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="nav_review_checkbox">
                                    <label class="form-check-label" for="nav_review_checkbox">
                                        Review
                                    </label>
                                </div>
                            </div>
                            
                            <!-- Question Navigation Buttons -->
                            <div class="questions-nav-container">
                                <div class="d-flex flex-wrap">
                                    {% for question in questions %}
                                        <button class="btn btn-outline-primary question-nav-btn" data-question-id="{{ question.id }}">
                                            {{ question.order_number }}
                                        </button>
                                    {% endfor %}
                                </div>
                            </div>
                            
                            <!-- Navigation Controls -->
                            <div class="navigation-controls">
                                <button class="btn btn-secondary btn-sm me-1" id="prevBtn">← Prev</button>
                                <button class="btn btn-secondary btn-sm me-1" id="nextBtn">Next →</button>
                                <button class="btn btn-primary btn-sm" id="submitBtn">Submit</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Submit Confirmation Modal -->
        <div class="modal fade" id="submitModal" tabindex="-1" aria-labelledby="submitModalLabel" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="submitModalLabel">Confirm Submission</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        Are you sure you want to submit your practice? You won't be able to make changes after submission.
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <a href="{% url 'submit_test' session.id %}" class="btn btn-primary">Submit Practice</a>
                    </div>
                </div>
            </div>
        </div>
        
    <!-- Bootstrap JS Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Custom JS -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const timerEl = document.getElementById('timer');
            const questionItems = document.querySelectorAll('.question-item');
            const navigationBtns = document.querySelectorAll('.question-nav-btn');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const submitBtn = document.getElementById('submitBtn');
            const answerInputs = document.querySelectorAll('.answer-input');
            const navReviewCheckbox = document.getElementById('nav_review_checkbox');
            
            // Set up CSRF token for AJAX requests
            const csrfToken = "{{ csrf_token }}";
            
            let currentQuestionIndex = 0;
            let remainingSeconds = parseInt(timerEl.dataset.remaining);
            
            // Update timer every second
            const timerInterval = setInterval(function() {
                remainingSeconds--;
                
                if (remainingSeconds <= 0) {
                    clearInterval(timerInterval);
                    timerEl.textContent = "Time's up!";
                    
                    // Auto-submit the test
                    window.location.href = "{% url 'submit_test' session.id %}";
                } else {
                    const minutes = Math.floor(remainingSeconds / 60);
                    const seconds = remainingSeconds % 60;
                    timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }
            }, 1000);

            // Show a specific question and scroll to it
            function showQuestion(index) {
                if (index < 0 || index >= questionItems.length) return;
                
                // Remove active class from all questions
                questionItems.forEach(item => item.classList.remove('active'));
                
                // Add active class to the target question
                const targetQuestion = questionItems[index];
                targetQuestion.classList.add('active');
                
                // Scroll to the target question
                targetQuestion.scrollIntoView({ behavior: 'smooth', block: 'start' });
                
                // Update current question index
                currentQuestionIndex = index;
                
                // Update navigation button states
                prevBtn.disabled = index === 0;
                nextBtn.disabled = index === questionItems.length - 1;
                
                // Update the review checkbox in navigation based on current question's review status
                updateNavigationCheckbox(index);
                
                // Highlight the corresponding navigation button
                updateNavigationHighlight(index);
            }
            
            // Update navigation highlight
            function updateNavigationHighlight(index) {
                navigationBtns.forEach((btn, btnIndex) => {
                    // Remove active class from all buttons
                    btn.classList.remove('active');
                    
                    // For each button that is not the current one and not answered
                    if (btnIndex !== index && !btn.classList.contains('answered')) {
                        // Make sure it has the btn-outline-primary class
                        btn.classList.add('btn-outline-primary');
                        btn.classList.remove('btn-primary');
                    }
                    
                    // Set the active class for the current question
                    if (btnIndex === index) {
                        btn.classList.add('active');
                    }
                });
            }
            
            // Update navigation checkbox based on question review status
            function updateNavigationCheckbox(index) {
                const questionItem = questionItems[index];
                const reviewBadge = questionItem.querySelector('.review-badge');
                navReviewCheckbox.checked = reviewBadge.classList.contains('visible');
            }
            
            // Navigation button event listeners
            navigationBtns.forEach((btn, index) => {
                btn.addEventListener('click', () => {
                    showQuestion(index);
                });
            });
            
            // Question item click event listeners
            questionItems.forEach((item, index) => {
                item.addEventListener('click', () => {
                    showQuestion(index);
                });
            });
            
            // Previous button event listener
            prevBtn.addEventListener('click', () => {
                if (currentQuestionIndex > 0) {
                    showQuestion(currentQuestionIndex - 1);
                }
            });
            
            // Next button event listener
            nextBtn.addEventListener('click', () => {
                if (currentQuestionIndex < questionItems.length - 1) {
                    showQuestion(currentQuestionIndex + 1);
                }
            });
            
            // Submit button event listener
            submitBtn.addEventListener('click', () => {
                const submitModal = new bootstrap.Modal(document.getElementById('submitModal'));
                submitModal.show();
            });
            
            // Save answer when input changes
            answerInputs.forEach(input => {
                if (input.type === 'radio') {
                    // For radio buttons, add click handler to allow deselection
                    input.addEventListener('click', (e) => {
                        // Find all radio buttons in the same group
                        const name = input.getAttribute('name');
                        const radioGroup = document.querySelectorAll(`input[name="${name}"]`);
                        
                        // If this radio is already checked, uncheck it and prevent default
                        if (input.getAttribute('data-previously-checked') === 'true') {
                            e.preventDefault();
                            
                            // Uncheck this radio button
                            input.checked = false;
                            
                            // Reset the previously-checked attribute for all radios in the group
                            radioGroup.forEach(radio => {
                                radio.setAttribute('data-previously-checked', 'false');
                            });
                            
                            // Call saveAnswer with the container to handle the deselection
                            const container = input.closest('.question-container');
                            saveAnswerForContainer(container, '');
                        } else {
                            // Update previously-checked attribute for all radios in the group
                            radioGroup.forEach(radio => {
                                radio.setAttribute('data-previously-checked', 'false');
                            });
                            
                            // Mark only this one as checked
                            input.setAttribute('data-previously-checked', 'true');
                            
                            // Save the answer
                            saveAnswer(input);
                        }
                    });
                    
                    // Add focus event to update navigation when clicking on a radio button
                    input.addEventListener('focus', () => {
                        // Find the question item and its index
                        const questionItem = input.closest('.question-item');
                        if (questionItem) {
                            const index = Array.from(questionItems).indexOf(questionItem);
                            if (index !== -1) {
                                showQuestion(index);
                            }
                        }
                    });
                } else {
                    // For other inputs like textareas
                    input.addEventListener('change', () => {
                        saveAnswer(input);
                    });
                    
                    if (input.tagName === 'TEXTAREA') {
                        // Add input event to catch deletions in real-time
                        input.addEventListener('input', () => {
                            saveAnswer(input);
                        });
                        
                        input.addEventListener('blur', () => {
                            saveAnswer(input);
                        });
                        
                        // Add focus event to update navigation when clicking in a textarea
                        input.addEventListener('focus', () => {
                            // Find the question item and its index
                            const questionItem = input.closest('.question-item');
                            if (questionItem) {
                                const index = Array.from(questionItems).indexOf(questionItem);
                                if (index !== -1) {
                                    showQuestion(index);
                                }
                            }
                        });
                    }
                }
            });
            
            // Navigation review checkbox event listener
            navReviewCheckbox.addEventListener('change', () => {
                const currentItem = questionItems[currentQuestionIndex];
                const questionId = currentItem.dataset.questionId;
                const markForReview = navReviewCheckbox.checked;
                
                // Update the review badge
                const reviewBadge = currentItem.querySelector('.review-badge');
                if (markForReview) {
                    reviewBadge.classList.add('visible');
                } else {
                    reviewBadge.classList.remove('visible');
                }
                
                // Get the answer value from the current question
                let answerValue = '';
                const container = currentItem.querySelector('.question-container');
                
                const radioInputs = container.querySelectorAll('input[type="radio"]:checked');
                if (radioInputs.length > 0) {
                    answerValue = radioInputs[0].value;
                } else {
                    const textarea = container.querySelector('textarea');
                    if (textarea) {
                        answerValue = textarea.value;
                    }
                }
                
                // Send the data to the server
                sendAnswerToServer(questionId, answerValue, markForReview);
                
                // Update the navigation button appearance for review status
                navigationBtns[currentQuestionIndex].classList.toggle('review', markForReview);
            });
            
            // Function to save an answer
            function saveAnswer(inputElement) {
                const container = inputElement.closest('.question-container');
                let answerValue;
                
                if (inputElement.type === 'radio') {
                    // For radio buttons, only get value if checked
                    answerValue = inputElement.checked ? inputElement.value : '';
                } else if (inputElement.tagName === 'TEXTAREA') {
                    answerValue = inputElement.value;
                }
                
                saveAnswerForContainer(container, answerValue);
            }
            
            // Function to save answer from a container
            function saveAnswerForContainer(container, answerValue) {
                const questionId = container.dataset.questionId;
                
                // Find the question item this answer belongs to
                const questionItem = container.closest('.question-item');
                const answeredBadge = questionItem.querySelector('.answered-badge');
                
                // Find which index this question is
                const questionIndex = Array.from(questionItems).findIndex(
                    item => item.dataset.questionId === questionId
                );
                
                if (questionIndex > -1) {
                    // Check if the answer is empty
                    if (answerValue && answerValue.trim() !== '') {
                        // Mark the corresponding nav button as answered
                        navigationBtns[questionIndex].classList.add('answered');
                        navigationBtns[questionIndex].classList.remove('btn-outline-primary');
                        
                        // Update the question item to show it's answered
                        questionItem.classList.add('answered');
                        
                        // Show the answered badge
                        answeredBadge.classList.add('visible');
                    } else {
                        // Remove answered class if answer is empty
                        navigationBtns[questionIndex].classList.remove('answered');
                        
                        // Update the question item to show it's not answered
                        questionItem.classList.remove('answered');
                        
                        // Hide the answered badge
                        answeredBadge.classList.remove('visible');
                        
                        // Always restore btn-outline-primary styling for unanswered questions
                        navigationBtns[questionIndex].classList.add('btn-outline-primary');
                        
                        // Only remove btn-primary if it's not the active question
                        if (questionIndex !== currentQuestionIndex) {
                            navigationBtns[questionIndex].classList.remove('btn-primary');
                        }
                    }
                }
                
                // Get the review status from the navigation review checkbox if this is the current question
                let markForReview = false;
                if (questionIndex === currentQuestionIndex) {
                    markForReview = navReviewCheckbox.checked;
                } else {
                    // For other questions, maintain their current review status
                    const reviewBadge = questionItem.querySelector('.review-badge');
                    markForReview = reviewBadge.classList.contains('visible');
                }
                
                // Send the data to the server
                sendAnswerToServer(questionId, answerValue || '', markForReview);
            }
            
            // Function to send answer to server
            function sendAnswerToServer(questionId, answer, markForReview) {
                const url = `{% url 'save_answer' session_id=session.id question_id=0 %}`.replace('0', questionId);
                
                const formData = new FormData();
                formData.append('answer', answer);
                formData.append('mark_for_review', markForReview);
                
                fetch(url, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': csrfToken,
                    },
                    body: formData,
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status !== 'success') {
                        console.error('Error saving answer:', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                });
            }
            
            // Initialize review markers and answered questions
            function initializeQuestionMarkers() {
                questionItems.forEach((item, index) => {
                    const answeredBadge = item.querySelector('.answered-badge');
                    const reviewBadge = item.querySelector('.review-badge');
                    
                    if (answeredBadge.classList.contains('visible')) {
                        item.classList.add('answered');
                        navigationBtns[index].classList.add('answered');
                        navigationBtns[index].classList.remove('btn-outline-primary');
                    }
                    
                    if (reviewBadge.classList.contains('visible')) {
                        navigationBtns[index].classList.add('review');
                    }
                });
            }
            
            // Mark previously checked radio buttons
            document.querySelectorAll('input[type="radio"]:checked').forEach(radio => {
                radio.setAttribute('data-previously-checked', 'true');
            });
            
            // Initialize: Highlight the first question by default
            showQuestion(0);
            initializeQuestionMarkers();
        });
    </script>
    
    <!-- Text Highlighting Implementation -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Target elements where we want to enable highlighting
            const readingPassage = document.querySelector('.reading-passage');
            const questionContainers = document.querySelectorAll('.question-container');
            
            // Track highlighted text spans
            let highlightedSpans = [];
            
            // Create and append the custom context menu
            const contextMenu = document.createElement('div');
            contextMenu.className = 'custom-context-menu';
            contextMenu.style.cssText = `
                position: absolute;
                background-color: white;
                border: 1px solid #ccc;
                border-radius: 4px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                padding: 5px 0;
                z-index: 1500;
                display: none;
            `;
            document.body.appendChild(contextMenu);
            
            // Add menu items to the context menu
            const highlightMenuItem = createMenuItem('Highlight', '#FFEB3B'); // Yellow highlight
            const removeHighlightMenuItem = createMenuItem('Remove Highlight');
            
            contextMenu.appendChild(highlightMenuItem);
            contextMenu.appendChild(removeHighlightMenuItem);
            
            // Function to create menu items
            function createMenuItem(text, color) {
                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                menuItem.textContent = text;
                menuItem.style.cssText = `
                    padding: 8px 12px;
                    cursor: pointer;
                    ${color ? `color: black;` : ''}
                `;
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.backgroundColor = '#f0f0f0';
                });
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.backgroundColor = 'transparent';
                });
                return menuItem;
            }
            
            // Apply context menu to reading passage
            if (readingPassage) {
                enableContextMenu(readingPassage);
            }
            
            // Apply context menu to all question containers
            questionContainers.forEach(container => {
                enableContextMenu(container);
            });
            
            // Function to enable context menu on an element
            function enableContextMenu(element) {
                element.addEventListener('contextmenu', function(e) {
                    e.preventDefault();
                    
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();
                    
                    // Check if selection contains any highlighted text
                    let selectionContainsHighlight = false;
                    let highlightSpansInSelection = [];
                    
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const container = document.createElement('div');
                        container.appendChild(range.cloneContents());
                        
                        // Check if this selection contains any highlighted spans
                        selectionContainsHighlight = container.querySelector('.highlighted-text') !== null;
                        
                        // Find all highlighted spans that intersect with the selection
                        document.querySelectorAll('.highlighted-text').forEach(span => {
                            if (selection.containsNode(span, true)) {
                                highlightSpansInSelection.push(span);
                            }
                        });
                    }
                    
                    // Only show menu if text is selected or click was on a highlight
                    if (selectedText || e.target.classList.contains('highlighted-text')) {
                        // Position the context menu
                        contextMenu.style.display = 'block';
                        contextMenu.style.left = `${e.pageX}px`;
                        contextMenu.style.top = `${e.pageY}px`;
                        
                        // Show both options if selection contains highlighted text and non-highlighted text
                        if (selectionContainsHighlight || e.target.classList.contains('highlighted-text')) {
                            highlightMenuItem.style.display = selectedText ? 'block' : 'none';
                            removeHighlightMenuItem.style.display = 'block';
                            
                            // Add click event to remove highlight
                            removeHighlightMenuItem.onclick = function() {
                                if (highlightSpansInSelection.length > 0) {
                                    // Remove all highlighted spans in the selection
                                    highlightSpansInSelection.forEach(span => {
                                        removeHighlight(span);
                                    });
                                } else if (e.target.classList.contains('highlighted-text')) {
                                    // Remove the specific target span
                                    removeHighlight(e.target);
                                }
                                hideContextMenu();
                            };
                            
                            // Add click event to apply highlight (if text is selected)
                            if (selectedText) {
                                highlightMenuItem.onclick = function() {
                                    applyHighlight(selection);
                                    hideContextMenu();
                                };
                            }
                        } else if (selectedText) {
                            // Regular text selection with no highlights
                            highlightMenuItem.style.display = 'block';
                            removeHighlightMenuItem.style.display = 'none';
                            
                            // Add click event to apply highlight
                            highlightMenuItem.onclick = function() {
                                applyHighlight(selection);
                                hideContextMenu();
                            };
                        } else {
                            // No text selected and not on a highlight, hide menu
                            hideContextMenu();
                        }
                    } else {
                        // No text selected, hide menu
                        hideContextMenu();
                    }
                });
            }
            
            // Hide context menu when clicking elsewhere
            document.addEventListener('click', hideContextMenu);
            document.addEventListener('scroll', hideContextMenu);
            window.addEventListener('resize', hideContextMenu);
            
            // Function to hide the context menu
            function hideContextMenu() {
                contextMenu.style.display = 'none';
            }
            
            // Function to apply highlight to selected text
            function applyHighlight(selection) {
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                
                // First, check if we need to remove any existing highlights in this selection
                const container = document.createElement('div');
                container.appendChild(range.cloneContents());
                const hasHighlights = container.querySelector('.highlighted-text') !== null;
                
                if (hasHighlights) {
                    // If selection contains highlights, first remove them
                    removePartialHighlights(selection);
                    
                    // We need to reselect the text after removing highlights
                    // This is complex, so we'll show a notification to the user
                    createNotification("Highlights removed. Please select the text again to apply new highlight.");
                    return;
                }
                
                // Apply new highlight
                const span = document.createElement('span');
                span.className = 'highlighted-text';
                span.style.backgroundColor = '#FFEB3B'; // Yellow highlight
                span.style.borderRadius = '2px';
                
                try {
                    range.surroundContents(span);
                    highlightedSpans.push(span);
                    selection.removeAllRanges();
                } catch (e) {
                    console.error("Highlighting failed, possibly due to partial node selection:", e);
                    
                    // Try a more complex approach for partial selections
                    try {
                        // Create a new range to hold our highlight
                        const newRange = document.createRange();
                        
                        // Extract the contents of the original range
                        const fragment = range.extractContents();
                        
                        // Create a span to wrap the extracted content
                        const highlightSpan = document.createElement('span');
                        highlightSpan.className = 'highlighted-text';
                        highlightSpan.style.backgroundColor = '#FFEB3B';
                        highlightSpan.style.borderRadius = '2px';
                        
                        // Append the content to our span
                        highlightSpan.appendChild(fragment);
                        
                        // Insert the highlight span at the start of the original range
                        range.insertNode(highlightSpan);
                        
                        // Track the new highlight
                        highlightedSpans.push(highlightSpan);
                        
                        // Clear the selection
                        selection.removeAllRanges();
                    } catch (nestedError) {
                        console.error("Complex highlighting also failed:", nestedError);
                        // Notify user why highlighting failed
                        createNotification("Highlight failed. Please select complete words or sentences.");
                    }
                }
            }
            
            // Function to remove highlight
            function removeHighlight(highlightSpan) {
                if (!highlightSpan) return;
                
                // Get the parent node of the highlight span
                const parent = highlightSpan.parentNode;
                
                // Create a document fragment to hold the highlight's contents
                const fragment = document.createDocumentFragment();
                
                // Move all the highlight's children to the fragment
                while (highlightSpan.firstChild) {
                    fragment.appendChild(highlightSpan.firstChild);
                }
                
                // Replace the highlight span with its contents
                parent.replaceChild(fragment, highlightSpan);
                
                // Remove the span from our tracked array
                highlightedSpans = highlightedSpans.filter(span => span !== highlightSpan);
                
                // Normalize the parent to merge any adjacent text nodes
                parent.normalize();
            }
            
            // Function to handle selection that spans across multiple highlights
            function removePartialHighlights(selection) {
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                
                // Get all highlighted spans in the document
                const allHighlightedSpans = document.querySelectorAll('.highlighted-text');
                
                // Find spans that intersect with the current selection
                allHighlightedSpans.forEach(span => {
                    // Check if this span intersects with the selection
                    if (selection.containsNode(span, true)) {
                        removeHighlight(span);
                    }
                });
            }
            
            // Function to create temporary notification
            function createNotification(message) {
                const notification = document.createElement('div');
                notification.className = 'highlight-notification';
                notification.textContent = message;
                notification.style.cssText = `
                    position: fixed;
                    bottom: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 10px 15px;
                    border-radius: 4px;
                    z-index: 2000;
                    font-size: 14px;
                `;
                
                document.body.appendChild(notification);
                
                // Remove after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transition = 'opacity 0.5s';
                    setTimeout(() => document.body.removeChild(notification), 500);
                }, 3000);
            }
            
            // Add keyboard shortcut (Ctrl+H) for highlighting
            document.addEventListener('keydown', function(e) {
                // Check if Ctrl+H was pressed
                if (e.ctrlKey && e.key === 'h') {
                    e.preventDefault(); // Prevent browser's history shortcut
                    
                    const selection = window.getSelection();
                    const selectedText = selection.toString().trim();
                    
                    if (selectedText) {
                        applyHighlight(selection);
                    }
                }
            });
        });
    </script>
</body>
</html>